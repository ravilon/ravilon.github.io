<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <title>Converter Vídeo em Áudio (Client-side)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg:#0f172a; --card:#111827; --muted:#9ca3af; --text:#e5e7eb;
      --accent:#22c55e; --warn:#f59e0b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 20% -20%, #1f2937 0%, transparent 60%), var(--bg);
      color: var(--text); min-height: 100vh; display: grid; place-items: center; padding: 24px;
    }
    .card {
      width: 100%; max-width: 720px; background: linear-gradient(180deg,#111827 0%, #0b1220 100%);
      border: 1px solid rgba(255,255,255,.05); border-radius: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35); padding: 22px;
    }
    h1 { margin: 0 0 6px; font-size: 1.35rem; }
    p.subtitle { margin: 0 0 18px; color: var(--muted); font-size: .95rem; }
    .row { display: grid; gap: 14px; grid-template-columns: 1fr; }
    @media (min-width: 640px){ .row{ grid-template-columns: 1fr 200px; } }
    label { font-size: .9rem; color: var(--muted); display: block; margin-bottom: 6px; }
    input[type="file"], input[type="number"], input[type="text"], select {
      width: 100%; padding: 12px 14px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12); background: #0b1220; color: var(--text);
    }
    .actions { display: flex; gap: 12px; margin-top: 16px; flex-wrap: wrap; }
    button {
      border: 1px solid rgba(255,255,255,.1); background: #0d1324; color: var(--text);
      padding: 12px 14px; border-radius: 12px; cursor: pointer;
      transition: .15s transform ease, .15s background ease, .15s border-color ease;
    }
    button.primary { background: linear-gradient(180deg, #10b981, #059669); border-color: #10b981; }
    button.primary:hover { filter: brightness(1.05); transform: translateY(-1px); }
    .status { margin-top: 14px; font-size: .9rem; color: var(--muted); }
    .pill {
      display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); font-size:.85rem;
    }
    .ok { color: var(--accent); }
    .warn { color: var(--warn); }
    .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:14px; margin-top:14px; }
    .toggle { display:flex; align-items:center; gap:10px; }
    .footer { margin-top: 18px; font-size: .8rem; color: var(--muted); }
    .hint { font-size:.8rem; color: var(--muted); margin-top:6px;}
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .progress { margin-top:8px; height:8px; background:#0b1220; border:1px solid rgba(255,255,255,.08); border-radius:999px; overflow:hidden;}
    .progress > div { height:100%; width:0%; background:#22c55e; transition:width .25s ease; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Converter Vídeo em Áudio</h1>
    <p class="subtitle">Selecione um vídeo e gere um arquivo de áudio (MP3/OGG/WAV) totalmente no seu navegador.</p>

    <div class="row">
      <div>
        <label for="file">Arquivo de vídeo (ex.: .mp4, .mov, .mkv, .webm)</label>
        <input id="file" type="file" accept="video/*" />
        <div id="videoInfo" class="hint"></div>
      </div>
      <div>
        <label for="format">Formato de saída</label>
        <select id="format">
          <option value="mp3">MP3 (compatível)</option>
          <option value="ogg">OGG (libvorbis)</option>
          <option value="wav">WAV (sem perdas)</option>
        </select>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label for="bitrate">Bitrate (áudio)</label>
        <select id="bitrate">
          <option value="128">128 kbps</option>
          <option value="192" selected>192 kbps</option>
          <option value="256">256 kbps</option>
          <option value="320">320 kbps</option>
        </select>
      </div>
      <div>
        <label for="samplerate">Sample rate (WAV)</label>
        <select id="samplerate">
          <option value="44100" selected>44.1 kHz</option>
          <option value="48000">48 kHz</option>
        </select>
        <div class="hint">Usado apenas quando o formato é WAV.</div>
      </div>
    </div>

    <div class="grid2">
      <div>
        <label for="start">Início (opcional)</label>
        <input id="start" type="text" placeholder="00:00:00 ou segundos" />
      </div>
      <div>
        <label for="duration">Duração (opcional)</label>
        <input id="duration" type="text" placeholder="00:01:30 ou segundos" />
      </div>
    </div>

    <div class="actions">
      <button id="previewBtn">Pré-visualizar</button>
      <button id="convertBtn" class="primary" disabled>Converter & Baixar</button>
    </div>

    <div id="status" class="status">Aguardando arquivo...</div>
    <div class="progress"><div id="bar"></div></div>
    <div id="stats" class="status"></div>
    <div class="footer">Tudo é processado localmente com FFmpeg.wasm. Arquivos grandes exigem mais CPU/RAM.</div>
  </div>

  <!-- Loader resiliente de FFmpeg.wasm: tenta múltiplas CDNs e núcleos compatíveis -->
  <script>
    // ======= Utilidades de UI =======
    const $ = (q) => document.querySelector(q);
    const setStatus = (msg, type = "") => { const s=$("#status"); if(s) s.innerHTML = `<span class="pill ${type}">${msg}</span>`; };
    const setStats  = (msg) => { const s=$("#stats"); if(s) s.textContent = msg || ""; };
    const setProgress = (ratio=0) => { const bar=$("#bar"); if(bar) bar.style.width = Math.max(0,Math.min(100,Math.round(ratio*100)))+"%"; };
    const resetProgress = ()=> setProgress(0);

    // ======= Carregador resiliente =======
    // URLs UMD (wrapper JS) – mesma versão
    const UMD_CANDIDATES = [
      "https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js",
      "https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js",
      "https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.12.10/ffmpeg.min.js" // fallback extra
    ];
    // URLs do core single-thread (precisam casar com a versão do UMD)
    const CORE_CANDIDATES = [
      "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js",
      "https://unpkg.com/@ffmpeg/core@0.12.10/dist/ffmpeg-core.js",
      "https://cdnjs.cloudflare.com/ajax/libs/ffmpeg-core/0.12.10/ffmpeg-core.js"
    ];

    // injeta <script> e aguarda carregar/erro
    function loadScript(url){
      return new Promise((resolve, reject)=>{
        const s = document.createElement("script");
        s.src = url;
        s.async = true;
        s.crossOrigin = "anonymous";
        s.referrerPolicy = "no-referrer";
        s.onload = ()=> resolve(url);
        s.onerror = ()=> reject(new Error("Falha ao carregar: "+url));
        document.head.appendChild(s);
      });
    }

    async function loadFFmpegUMD(){
      for (const url of UMD_CANDIDATES){
        try{
          setStatus("Carregando biblioteca FFmpeg.wasm...", "");
          await loadScript(url);
          // aguarda o global aparecer
          for (let i=0;i<20;i++){
            if (window.FFmpeg && window.FFmpeg.createFFmpeg) {
              setStatus("Biblioteca FFmpeg carregada.", "ok");
              return true;
            }
            await new Promise(r=>setTimeout(r, 100));
          }
          // se não expôs global, tenta o próximo
        }catch(e){
          // tenta próximo
        }
      }
      return false;
    }

    // garante instancia do ffmpeg com algum corePath que funcione
    async function ensureFFmpeg(){
      if (window.__ffmpegLoaded) return;
      if (!window.FFmpeg || !window.FFmpeg.createFFmpeg){
        const ok = await loadFFmpegUMD();
        if (!ok) throw new Error("Biblioteca FFmpeg.wasm não carregou. Verifique conexão/CDN.");
      }
      const { createFFmpeg } = window.FFmpeg;

      let lastError = null;
      // tenta múltiplos corePaths até um funcionar
      for (const corePath of CORE_CANDIDATES){
        try{
          setStatus("Inicializando FFmpeg...", "");
          const ff = createFFmpeg({ log:true, corePath });
          ff.setProgress?.(({ratio})=> setProgress(ratio || 0));
          await ff.load(); // se falhar, cai no catch e tenta o próximo core
          window.__ffmpeg = ff;
          window.__ffmpegLoaded = true;
          setStatus("FFmpeg pronto.", "ok");
          return;
        }catch(e){
          lastError = e;
        }
      }
      throw lastError || new Error("Não foi possível inicializar o FFmpeg core.");
    }
  </script>

  <!-- App -->
  <script>
    const fileInput = $("#file");
    const formatSelect = $("#format");
    const bitrateSelect = $("#bitrate");
    const samplerateSelect = $("#samplerate");
    const startInput = $("#start");
    const durationInput = $("#duration");
    const previewBtn = $("#previewBtn");
    const convertBtn = $("#convertBtn");
    const videoInfoEl = $("#videoInfo");

    let sourceName = "video";

    function mimeFor(fmt){
      if (fmt === "mp3") return "audio/mpeg";
      if (fmt === "ogg") return "audio/ogg";
      return "audio/wav";
    }

    function downloadBlob(u8, filename, type){
      const blob = (u8 instanceof Uint8Array) ? new Blob([u8], { type }) : new Blob([u8], { type });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function handleError(e){
      console.error(e);
      setStatus(`Erro: ${e.message || e}`, "warn");
    }

    function parseTimeInput(v){
      if(!v) return "";
      const s = v.trim();
      if (!s) return "";
      if (/^\d+(\.\d+)?$/.test(s)) return s;
      const m = s.match(/^(\d{1,2}):([0-5]?\d):([0-5]?\d(?:\.\d+)?)$/);
      if (!m) throw new Error("Tempo inválido. Use segundos ou HH:MM:SS");
      const hh = parseInt(m[1],10), mm = parseInt(m[2],10), ss = parseFloat(m[3]);
      return String(hh*3600 + mm*60 + ss);
    }

    async function probeVideo(file){
      return new Promise((resolve,reject)=>{
        const url = URL.createObjectURL(file);
        const v = document.createElement("video");
        v.preload = "metadata";
        v.src = url;
        v.onloadedmetadata = () => {
          const duration = v.duration || 0;
          const w = v.videoWidth, h = v.videoHeight;
          URL.revokeObjectURL(url);
          resolve({ duration, width:w, height:h });
        };
        v.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error("Não foi possível ler metadados do vídeo."));
        };
      });
    }

    fileInput.addEventListener("change", () => {
      setStats("");
      resetProgress();
      const file = fileInput.files?.[0];
      if (!file) { setStatus("Aguardando arquivo..."); convertBtn.disabled = true; return; }
      sourceName = (file.name || "video").replace(/\.[^.]+$/,"");
      setStatus(`Arquivo selecionado: ${file.name}`, "ok");
      convertBtn.disabled = false;
      videoInfoEl.textContent = "";
    });

    previewBtn.addEventListener("click", async () => {
      try {
        const file = fileInput.files?.[0];
        if (!file) throw new Error("Selecione um arquivo primeiro.");
        setStatus("Lendo metadados...");
        const meta = await probeVideo(file);
        const dur = isFinite(meta.duration) ? meta.duration : 0;
        const hh = String(Math.floor(dur/3600)).padStart(2,"0");
        const mm = String(Math.floor((dur%3600)/60)).padStart(2,"0");
        const ss = String(Math.floor(dur%60)).padStart(2,"0");
        videoInfoEl.innerHTML = `Duração: <span class="mono">${hh}:${mm}:${ss}</span> • Resolução: <span class="mono">${meta.width}×${meta.height}</span>`;
        setStatus("Pré-visualização pronta.", "ok");
        setStats(`Tamanho do arquivo: ~${(file.size/1024/1024).toFixed(2)} MB`);
      } catch(e){ handleError(e); }
    });

    convertBtn.addEventListener("click", async () => {
      try {
        const file = fileInput.files?.[0];
        if (!file) throw new Error("Selecione um arquivo primeiro.");

        resetProgress();
        setStatus("Verificando FFmpeg...", "");
        await ensureFFmpeg();

        const { fetchFile } = window.FFmpeg;
        const ffmpeg = window.__ffmpeg;

        const inName = "input" + (file.name.match(/\.[^.]+$/)?.[0] || ".mp4");
        setStatus("Preparando entrada...", "");
        ffmpeg.FS("writeFile", inName, await fetchFile(file));

        const outFormat = formatSelect.value;
        const bitrate = bitrateSelect.value;
        const samplerate = samplerateSelect.value;
        const start = parseTimeInput(startInput.value);
        const duration = parseTimeInput(durationInput.value);

        const args = [];
        if (start) args.push("-ss", start);
        args.push("-i", inName, "-vn"); // sem vídeo
        if (duration) args.push("-t", duration);

        let outName;
        if (outFormat === "mp3") {
          outName = `${sourceName}.mp3`;
          args.push("-acodec","libmp3lame","-b:a", `${bitrate}k`, outName);
        } else if (outFormat === "ogg") {
          outName = `${sourceName}.ogg`;
          // mapeia bitrate para qualidade aproximada (VBR)
          args.push("-c:a","libvorbis","-q:a", String(Math.max(3, Math.min(6, Math.round((+bitrate)/64)))), outName);
        } else {
          outName = `${sourceName}.wav`;
          args.push("-acodec","pcm_s16le","-ar", samplerate, outName);
        }

        setStatus("Convertendo...");
        await ffmpeg.run(...args);

        setStatus("Finalizando...", "");
        const data = ffmpeg.FS("readFile", outName);
        downloadBlob(data, outName, mimeFor(outFormat));

        setStatus("Áudio gerado com sucesso!", "ok");
        setStats(`Arquivo: ${outName} • ${(data.length/1024/1024).toFixed(2)} MB`);
      } catch(e){ handleError(e); }
    });
  </script>
</body>
</html>
